

# AVL树算法简介

AVL是一种自平衡查找树，在插入和删除的时候会通过**旋转**来保持树的平衡。本篇文章对AVL树的原理做了一些介绍，并给出了对应的C++代码，简单易懂。

本文的目录如下:



[TOC]



## AVL树简介

AVL树首先是一种二叉搜索树，如果不知道什么是二叉查找树请先参看，其中提到关于遍历、插入、删除的算法不在本文的讨论范围内。

> [二叉查找树-百度百科](http://baike.baidu.com/item/%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91?fromtitle=%E4%BA%8C%E5%8F%89%E6%9F%A5%E6%89%BE%E6%A0%91&fromid=7077965&type=syn&sefr=cr)
>
> [Binary search tree-Wiki](https://en.wikipedia.org/wiki/Binary_search_tree)

但是二叉搜索插入时容易使左右子树高度相差过大，也就是不平衡，导致搜索的时间复杂度增大。为了解决这种问题而出现了AVL树。AVL树是一种自平衡的二叉查找树，通过旋转操作可以保持树的平衡。

## AVL树相关术语介绍

- 深度：从目标节开始点的最多的子树层数
- 平衡因子(BF)：目标节点的左子树深度减右子树的深度
- 旋转：为了保持树的平衡而对不平衡节点进行处理的行为
- 回溯：从叶子节点开始，访问父节点直到根节点的行为
- 平衡:  所有节点的BF的绝对值<2
- 失衡: 某一节点BF值 =2

## AVL树相关算法简介

## 回溯

### 插入回溯

AVL树是否平衡，是通过判断其BF值来判断的，所以每次插入之后都必须对所有的BF值进行更新。而BF值又是根据节点的左右子树的深度定义的，那是否每一次都需要遍历每一个节点，并得到左右子树的深度进行减法呢？肯定是不需要的，这样需要耗费巨大时间。在描述回溯之前先给出几个推论:

1. 新插入的节点的BF值始终为0
2. 插入一个新节点只会对新节点的祖先节点的BF值进行改变。
3. 如果一个现存节点node的BF在插入时改变，如过新节点插入到node的左子树，则node的BF+1，否则-1

如何判断新节点插入到祖先节点的左字数还是右子树呢？由于AVL树是一个搜索树，所以当新节点的值小于祖先点时，新节点的一定插入到它的左边，否则就在右边。

在插入后新节点后，需要逐个更改该节点的祖先节点的BF值直到根节点，这就回溯的过程。在回溯的过程中，如果某节点BF值变为0，则停止回溯，不做旋转处理。如果BF的值变为+2或2，就需要停止回溯，并对判断该节点的失衡类型并进行旋转处理。具体的判断处理方式在下文中给出。

## 旋转

AVL树最重要的一个概念就是旋转。旋转也是本文篇幅最大的部分。在插入和删除使树不平衡时，需要使用旋转操作保持平衡。旋转分为左旋或右旋，在很多网络上都没有给出旋转的具体定义，而是给了一个图片来描述，其实这样根本没有办法理解旋转，因为写在代码里面一定需要明确的定义，而不是一个模糊的左旋或右旋概念，比较计算机不知道什么是左旋，什么是右旋。下面就通过图片来举例说明左旋转和右旋转的明确定义

### 左旋转



![左旋转](http://www.z4a.net/images/2017/03/11/IMG_20170311_212438.md.jpg)

画图太痛苦了(ORZ)还是用手画代替吧。。从图中可以看出根节点为15，根节点的左子树略去。设图根节点为平衡节点，则图中只有一个失衡节点为15。可以算出，15节点的BF值为-2。于是通过对15节点进行了左旋转，得到的结果可以看出14节点取代了11节点的位置，且旋转后的树中没有失衡的节点。因此通过旋转操作纠正了失衡的树。那到底旋转中到底经历了哪些步骤呢？是否有一种通用的方法来答到旋转的目的呢？答案是肯定。

首先看旋转后和旋转前的差别：

1. 指向15节点的指针指向了17节点(15节点的右节点)(未画出)
2. 15节点变为了17节点的左节点
3. 16节点变为了15节点的右节点(以前放在17节点的左节点)

其实所有的节点左旋转都经历了以上步骤，于是可以将左旋转做以下抽象，将需要旋转的节点定义为**目标节点** ，将目标节点的**右节点**定义为**轴节点** ：

1. 如果目标节点存在父节点，将轴节点代替目标节点
2. 如果目标节点是根节点，将轴节点置为根节点
3. 如果轴节点存在左节点，保存它
4. 将目标节点作为轴节点左节点
5. 如果步骤2保存了子节点，则将子节点作为目标节点的右节点

其实从图中可以看出，图的变换就像把目标节点15绕着轴节点17从左向右旋转了一样，所以称之为左旋(有时候也叫逆旋)。

### 右旋转

同时，右旋也和左旋一样，可以通过描述节点之间的指向关系变换来描述。这里只给出图片和定义:

![右旋转](http://www.z4a.net/images/2017/03/11/IMG_20170311_212421.md.jpg)



目标节点为15节点，依然将需要旋转的节点定义为**目标节点** ，将目标节点的**左节点** 定义为**轴节点** ，注意这里的轴节点定义的为目标节点的**左节点** 。右旋定义如下

1. 如果目标节点存在父节点，将轴节点代替目标节点
2. 如果目标节点是根节点，将轴节点置为根节点
3. 如果轴节点存在右节点，保存它
4. 将目标节点作为轴节点右节点
5. 如果步骤2保存了子节点，则将子节点作为目标节点的左节点

可以看出，右旋和左旋其实互成镜像关系，步骤都是一样的。

### 旋转类型

从上面两个例子可以看出通过旋转可以让树平衡，但是是否只有这两种选择方式呢，其实在AVL树其中有四种处理不平衡的方法，其中两种是需要进行两次旋转。先给出失衡类型，每一种类型对应一种处理方式。

根据对应的编号可以分为:

1. 左左(LL)
2. 左右(LR)
3. 右右(RR)
4. 右左(RL)

其中处理方式为:

1. 右旋
2. 先将失衡节点的左节点左旋，再右旋失衡节点
3. 左旋
4. 先将失衡节点的右节点右旋，再左旋失衡节点

如何判断失衡的类型呢，这里先给出两个定义:

- 目标节点：失衡的节点
- 轴节点:：如果目标节点BF值为-2，轴节点为目标节点的右节点，如果BF为2，则轴节点为左节点

失衡情况可以通过目标节点和轴节点进行定义

```c++
if 失衡节点的BF值为2
   else if 轴节点BF值为1 
	失衡方式为 LL
  else if 轴节点的左节点BF值为-1
	失衡方式为 LR
    
if 失衡节点的BF值为-2
  else if 轴节点的右节点BF值为-1
    失衡方式为 RL
  else if 轴节点的右节点的BF为 1
    失衡方式为  RR
```

所以只需要判断失衡节点和其左/右节点的BF值就可以判断旋转方式了。说到这里，有的人可能会发现 ，在判断时轴节点的值只取了+1和-1两个值，那有不有可能出现为0的情况呢？这里给出一个推论：

> 在插入时，如果出现失衡的目标节点，其轴节点的BF值一定不为0

### 旋转后更新平衡因子

在旋转后，需要对不平衡子树的平衡因子进行更新，先介绍一个推论:

> 旋转后，只有目标节点和轴节点的平衡因子会因旋转改变

所以旋转后需要更新的只有目标节点和轴节点的平衡因子需要更新，这也是网上许多教程没有提到的。先给出伪代码：

当左旋时:

```c++
if B1 > 0 
         new B2 = B2 + 1;
         new B1 = (B1 + B2 + 1) > (B1 + 1) ? (B1 + B2 + 1) : (B1 + 1);
else
        new B2 = B2 - B1 + 1;
        new B1 = ( B2 + 2 ) > (B1 + 1) ? (B2 + 2 ) : ( B1 + 1 );
```

当右旋时:

```c++
if B1 > 0
         new B2 = B2 - B1 -1;
         new B1 = (B1 - 1) < ( B2 - 2 ) ? (B1-1) : (B2 - 2);
else
         new B2 = B2-1;
         new B1 = (B1 - 1) < ( B1 + B2 - 2 ) ? ( B1-1 ) : (B1 + B2 - 2);
    
```

其中B2表示目标节点的BF值，B1表示轴节点的值。new 表示更新后的值。 

## AVL树的生成

### AVL树的插入

在了解回溯以及平衡之后，就可以构建一个AVL树了，构建一个AVL的步骤如下:

1. 使用查找树的方式插入一个数据

2. 插入的节点开始回溯，逐个修改BF值

3. 当遇到BF修改后的值为0时，退出回溯。

   当遇到BF修改后的值为2时，该节点为失衡节点，判断该节点的失衡类型，并进行旋转。

每一次的插入操作都会进行以上三个步骤，这样就能保证树始终是平衡的.

### AVL树的删除

删除和插入其实有异曲同工之妙，大体步骤都是一样的，先删除，再平衡。但是依旧存在几个同的地方，总的说，删除要比插入困难一些。不同点如下:

1. 判断旋转的方式不同:

   在插入章节有一个推论，即轴节点不可能出现BF值为零的情况。但是在删除的过程中，轴节点的BF值可能为0，这时候需要根据目标节点类型来判断旋转方式。写成伪代码如下:

   ```c++
   if 失衡节点的BF值为2
     	else if 轴节点BF值为1 
      		失衡方式为 LL
       else if 轴节点的左节点BF值为-1
       	失衡方式为 LR
      else if 轴节点的左节点BF值为0
      		失衡方式为LLS
       
   if 失衡节点的BF值为-2
       else if 轴节点的右节点BF值为-1
           失衡方式为 RL
       else if 轴节点的右节点的BF为 1
           失衡方式为  RR
       else if 轴节点的右节点的BF为 0
         	失衡方式是 RRS
   ```

   其中LLS和RRS的处理方式与LL，RR相同，为什么要单独作为一个方式呢？下一点将会提到：

2. 回溯方式不同:

   当在插入时，停止回溯有以下三种情况:

   * 某节点BF值修改后值为0，退出回溯，不做任何处理。
   * 某节点BF值修改后变为2或-2，退出回溯，做平衡处理。
   * 遇到根节点

   但是在删除时，停止回溯的情况有所不同:

   * 某节点的BF值修改后变为-1或1，退出回溯，不做任何处理。
   * 某节点的BF值变为2或-2且旋转方式为LLS或RRS。退出回溯，做平衡处理。
   * 遇到根节点

从上面可以看出，删除时如果遇到不平衡节点，且旋转方式不是LLS或RRS之中的一种便不能停止回溯，直到根节点为止。所以在遇到失衡节点时，可以将失衡节点放在一个数组中，回溯完成后再逐渐进行旋转平衡处理。删除和插入回溯主要就是以上的不同点，在节点的旋转方面是一模一样，可以将不同的旋转封装为函数，然后直接调用。

## AVL代码实现

下面将利用C++对AVL主要的实现部分进行实现:

### 类的定义

* AVLTree:对树的操作方式进行封装
* Node:单一节点类

Node的属性定义如下:

```c++
    int BF;//平衡因子
    int value;//值
    Node* left;//左节点
    Node* right;//右节点
    Node* father;//父节点
```

### 判断旋转方式

```c++

AVLTree::TYPE AVLTree:: getInbalanceType(Node *inbalance_node){
    unsigned char code = 0x00;
    Node *next_node = nullptr;
    //判断位于失衡节点的左边还是右边
    if( inbalance_node->BF <0 ){
        code |= 0x90;//右子树
        next_node = inbalance_node->right;
    } else{
        code |= 0x60;
        next_node = inbalance_node->left;
    }
  
    switch (next_node->BF){
        case 0:  if(inbalance_node->BF < 0){
                code &= 0x00;
            }
            else{
                code |= 0xff;
            }
            break;
        case 1: code |= 0x06;
            break;
        case -1: code |= 0x09;
            break;
        default:;
    }

    return  (TYPE)code;
}
```

旋转方式的判断还是比较简单的，通过判断根节点与轴节点的负号关系就能判定旋转方式，其中TYPE是枚举变量

定义如下：

```c++
 enum  class TYPE{LL=0X66,LR=0X69,RL=0X96,RR=0X99,LLS = 0XFF,RRS = 0X00};
```

这里用了一个技巧，先通过目标节点确定高4位，然后通过轴节点确定低4位，然后转换为枚举变量，就能得到旋转的类型。

### 旋转

右旋代码如下：

```c++
void AVLTree:: rotateRight(Node *node){

    int B2 = node->BF; //旋转节点的BF值
    int B1 = node->left->BF;// 轴节点的BF值

    Node *temp_left_node = node->left;

    if(node->father != nullptr){
        reLink(node,node->left);           //1如果目标节点存在父节点，将轴节点代替目标节点
      									   //reLink的左右是将node->left 替换掉 node

    }

    Node *temp_node = node->left->right;     //3 如果轴节点存在右节点，保存它
    createLink(node->left,node,RIGHT);      //4  将目标节点作为轴节点右节点
    createLink(node,temp_node,LEFT);       //5   如果步骤2保存了子节点，则将子节点作为目标节点的左节点

    if(root == node){
        setAsRoot(node->father); // 2如果目标节点是根节点，将轴节点置为根节点。旋转后 轴节点已经变为目标节点的父节点
    } 
  
	//6更新BF值
    if(B1 > 0){
        node->BF = B2 - B1 -1;
        temp_left_node ->BF = (B1 - 1) < ( B2 - 2 ) ? (B1-1) : (B2 - 2);
    } else{
        node->BF = B2-1;
        temp_left_node ->BF = (B1 - 1) < ( B1 + B2 - 2 ) ? ( B1-1 ) : (B1 + B2 - 2);
    }
}
```

### 回溯

#### 插入时回溯

```c++
//插入时回溯
//插入时普遍满足小值位于左子树 ，大值或相等的值位于右子树
//所以可以采用值比较法判断插入位置从而修改BF值
Node* AVLTree:: reBackWhenInsert(Node *start_node){

    Node *now_node = start_node->father;
    int value = start_node->value;

    while(now_node != nullptr){

        int &BF = now_node->BF;
        (value >= now_node->value) ? BF-- : BF++;//插在左子树 BF++，否则BF--
        if(BF == 0){
            return nullptr;//BF变为0 消失
        }
        if(abs(BF) == 2){
            return now_node;//找到失衡节点 退出
        }

        now_node = now_node->father;//更新回溯节点
    }
    return nullptr;

```

左旋代码与右旋代码相似，不再给出。

#### 删除时回溯

```c++
//删除时回溯
//删除时树往往已经经历过若干次旋转 可能出现相等的值在左边的情况 所以不能使用值大小判断
//采用的是直接判断子节点与父节点的连接关系方式回溯 从而修改BF值
//接受的节点必须有父节点
Node * AVLTree::rebackWhenDelete(Node *startNode){

    Node *now_Node = startNode;
    while (now_Node -> father != nullptr){

        int &BF = now_Node->father->BF;//得到父节点的BF值
        ( getLinkType(now_Node) == LEFT ) ? BF-- : BF++;//如果删除点位于父节点的左边 BF值-1 或者+1
        if(abs(BF) == 1) {
            return nullptr;//如果BF值为1 退出
        }
        else if(abs(BF) == 2){
            return  now_Node->father; //找到失衡节点 退出
        }
        now_Node = now_Node->father ;
    }
}
```

调用时:

```c++
 //将所用不平衡的节点点放在一个数组中
    for(int i=0;  inbalance_node != nullptr;i++ ){

        TYPE type = getInbalanceType(inbalance_node); //先得到一个不平衡点
        inbalance_array[i] = inbalance_node;//放入数组

        //直到旋转方式为LLS或RRS或根为root才不继续回溯
        if(type == TYPE::LLS || type == TYPE::RRS || inbalance_node == root){
            break;
        }

        inbalance_node = rebackWhenDelete(inbalance_node);//当返回为空 即是 BF变为-1或1 也退出
    }
```



