---
title: 2016-12-8 6种构造相关函数
tags: C++,构造函数
grammar_cjkRuby: true
---
## 构造函数简介

构造函数是在创建对象是调用的一种特殊函数。与JAVA不同的是，C++共有6中关于对象创建/销毁的函数，分别是:

* 默认构造函数
* 拷贝构造函数
* 赋值运算符
* 移动构造函数
* 移动赋值运算符
* 析构函数

下面将对这几种函数进行比较和总结。

### 默认构造函数

默认构造函数是最基本的构造函数，当用一以下方式创建对象时，就会调用默认构造函数。

`string s = new string("c++");`

如果默认构造函数只有一个参数，则在某些情况会**自动包装** ,例如：

```c++
class A
{
  public:
  int value;
  A(int i):value(i){};
}
void fun(A a);
fun(1);
```

在以上代码中,传入到fun中的1会被传入A的构造函数并创建一个A的对象。这即是**自动包装**过程。

***



### 拷贝构造函数

拷贝构造函数是利用一个**已经创建好的对象去初始化一个并创建另一个对象**时会被调用，如下：

```c++
string s = "aaaa";
string s1(s);   //1
string s1 = string(s);
string s1 = s;  //2
string s1{s};
string s1 = {s};
```

以上这几种不同的方式都会调用拷贝构造函数去创建并初始化一个对象。其中，默认的拷贝构造函数是**浅拷贝**，浅拷贝在某些时候存在一定的不安全因素，如下:

```c++
class A
{
  string *p;
  ~A()
  {
   delete ;
  }
}
A a();
A b = a;
```

在上面的代码段中，首先会创建一个对象a，然后调用拷贝构造函数去初始化b。由于是浅拷贝,所以对象a,b中p的值指向的是同一个内存空间。随后在a,b被销毁的时候会调用两次析构函数,导致p被删除两次,这会出现不安全的因素，所以在有必要的时候可以自己重写拷贝函数来实现**深拷贝**。

***



### 移动构造函数

在讲移动构造函数之前必须讨论一个新的概念**右值引用**，在C++11引入右值引用之前，传统的引用使标示符关联到左值。左值是一个表示数据的表达式(如变量名或解除指针引用的指针)。左值引用可以出现在等式的左边。

在C++11中引入了右值引用，用&&表示。右值引用可以出现在赋值表达式的右边，但是不能对其使用地址运算符。右值引用包括字面常量，或如x+y表达式返回的值以及函数返回的临时对象。如下:

```c++
int x = 10;
int y = 23;
int && r1 = 13;
int && r2 = x + y;
```

在C++引入右值引用之前，可能会出现这样的情况：

```c++
class A
{
  	string * s;
  	A():{s = new s[1000]};
  	A(const A &a)//拷贝构造函数
    {
      //实现深拷贝代码
    }
  ~A()
  {
    delete []s;
  }
}
A func()
{
  //....
  return A();
}
A b() = func();
```

在上面的代码中,func会返回一个临时对象,然后使用深拷贝创建新的对象b,最后销毁临时对象。在这个过程中临时对象的创建是一个没有意义的过程，因为临时对象中的数据和最终初始化的b是相同的，而且需要耗费额外的时间。在这时，移动构造函数就有了用武之地。移动构造函数后，在上面的初始化过程会直接创建对象b而不是先创建临时对象，再将临时对象复制到对象b。这样就避免了创建临时对象出现的内存和时间的损耗。实现一个移动构造函数如下:

```c++
class A
{
  //...
  A(A &&a)//移动构造函数,这里A &&a表示a是一个右值引用
  {
    //...
  }
  //...
}
```

***

### 赋值运算符

在**两个对象都存在，并且将一个对象赋给另一个对象时会调用赋值运算符**，这是对**=**运算符重载实现的。同样，实现的是浅拷贝。如下面代码所以的1处的赋值：

```c++
string s = "c++";
string s1 ;
s1 = s;//调用赋值运算符 ---1
string s2 = s;//调用拷贝构造函数 ---2
```



需要注意的是2处，虽然看起来是利用 "=" 将s赋值给s2，但是此处调用的**拷贝构造函数**。原因是赋值时s2并不存在。

***

### 移动赋值运算符

移动赋值运算符和移动构造函数相同，在"="右边出现右值引用时会直接执行复制过程，而不会创建临时对象。

***

### 析构函数

析构函数是指对象在销毁时运行的函数，常常将对象中动态分配内存的释放写在此处。



 